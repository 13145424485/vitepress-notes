## 集合

### 集合框架介绍

集合（有时称为容器）只是一个将多个元素分组为一个单元的对象。用于存储，检索，操作和传达聚合数据

集合框架是用于表示和操作集合的统一体系结构



 

#### 为什么要使用集合框架

数组也能进行增删改查操作，那么数组与集合之间的差别在哪呢？

```java
package com.cyx.collection;

import java.util.Arrays;

/**
 * @author 22373
 */
public class ArrayUtil {
    //使用数组来存储数据，因为不知道存储什么样子的数据，所以使用object
    //支持存储所有类型的数据
    private Object[] elements;

    private int size;
    //  集合中存储的元素个数
    public ArrayUtil(){
        this(16);
    }
    public ArrayUtil(int capacity){
        elements = new Object[capacity];
    }
    public void add(Object o){
        if(size == elements.length){
            //集合满了，数组需要扩容才能存储新的元素
            //扩容
            //4 >>1  0100 >> 1 => 010 =2     右移一位相当于除2
            int length = elements.length+(elements.length>>1);
            elements = Arrays.copyOf(elements,length);
        }
        //赋完值后++
        elements[size++] = o;
    }

    /*
     * 删除指定元素
     */
    public void delete(Object o) {
        if (o == null) {
            return;
        }
        //要删除元素的下标
        int index = -1;
        for (int i = 0; i < size; i++) {
            if (o.equals(elements[i])) {
                index = i;
                break;
            }
        }
        //1 2 3 4 5
        //1 2 4 5
        System.arraycopy(elements, index + 1, elements, index, size - index - 1);
        size--;
        }
    /**
     * 修改
     */
    public void update(int index,Object o){
        if(index < 0 || index >= size){
            throw new ArrayIndexOutOfBoundsException("下标越界");
        }
        elements[index] = o;
    }
    /**
     * 查
     */
    public Object search(int index){
        if(index < 0 || index >= size){
            throw new ArrayIndexOutOfBoundsException("下标越界");
        }
        return elements[index];
    }
}


```

 使用数组对元素进行增删改查时，需要我们自己编码实现。而集合是Java平台提供的，也能进行增删改查，已经有了具体的实现。我们不需要再去实现，直接使用Java平台提供的集合即可，这无疑减少了编程的工作量。同时`java`平台提供的集合无论是在数据结构还是算法设计上都具有更优的性能。

#### 框架接口体系

![image-20241002195245774](C:\Users\22373\AppData\Roaming\Typora\typora-user-images\image-20241002195245774.png)

#### collection接口

```java
int size(;//获取集合的大小
boolean isEmpty();//判断集合是否存有元素
boolean contains(object o);//判断集合中是否包含给定的元素Iterator<E> iterator();//获取集合的迭代器
object[]toArray();//将集合转换为数组
<T> T[] toArray(T[] a);//将集合转换为给定类型的数组并将该数组返回boolean add(E e);//向集合中添加元素
boolean remove(object o);//从集合中移除给定的元素
void clear();//清除集合中的元素
boolean containsA11(co1lection<?> c);//判断集合中是否包含给定的集合中的所有元素
boolean addA11(co1lection<? extends E> c);//将给定的集合的所有元素添加到集合中

```

**AbstractCollection**

AbstractCollection实现了collection接口，属于单列集合的顶层抽象类

AbstractCollection抽象类中没有实现的方法，没有存储元素的容器，因此所有的核心方法都没有实现。

#### Iterator迭代器

**1.什么是迭代器**
集合是用来存储元素的，存储元素的目的是为了对元素进行操作，最常用的操作就是检索元素。为了满足这种需要，JDK提供了一个*Iterable*接口(表示可迭代的)，供所有单列集合来实现。

```java
public interface collection<E> extends Iterable<E>
```



可以看出，collection接口是Iterable接口的子接口，表示所有的单列集合都是可迭代的。Iterable接口中有一个约定

```java
Iterator<T> iterator();//获取集合的迭代器

因此所有单列集合必须提供一个迭代元素的迭代器。而迭代器Iterator也是一个接口。其中约定如下:
boolean hasNext();//判断迭代器中是否有下一个元素
E next();//获取迭代器中的下一个元素
default void remove();//将元素从迭代器中移除，默认是空实现
```

再使用通过迭代器遍历元素时。将元素强制转换成字符串当集合中存储**多种数据类型**时，**强制类型转换就会出现异常**。

使用迭代器遍历

```java
Collection col = new ArrayList();

Iterator iterator = col.iterator(); // 创建迭代器对象
// 判断集合是否有下一个元素
while(iterator.hasNext()){
	// 指针移动一个位置，返回集合该位置的元素
	Object tmp = iterator.next();
}

```



如果集合中只存储同一种数据类型，那么其中强制类型转换的异常就能得到解决。如何限制集合只能存储同一种数据呢？这就需要使用到泛型。

#### 泛型

简而言之，泛型在定义类，接口和方法时使类型（类和接口）成为参数，与方法声明中使用的更熟悉的形式参数非常相似，类型参数为你提供了一种使用不同输入重复使用相同代码的方法。区别在于形式参数的输入是值，而类型参数的输入是类型。

<font color = "red">泛型就是一个变量，只是该变量只能使用引用数据类型来赋值，这样能够使相同的被不同数据类型的数据重用</font>

##### 如何使用泛型

**包含泛型的类定义语法:**
通常使用的泛型变量:E T K V

```java
访间修饰符 class 类名<泛型变量>{
}
```

**包含泛型的接口定义语法:**

```java
访问修饰符 interface 接口名<泛型变量>{
}
```

**方法中使用新的泛型语法:**

```java
访问修饰符 泛型变量 返回值类型 方法名(泛型变量 变量名,数据类型1，变量名1,...,数据类型n，变量名n){
}
```



使用泛型改造自定义集合MyCollection

##### 泛型通配符

当使用泛型类或者接口时，如果泛型类型不能确定，可以通过通配符?表示。

**定义**

1. 在编程语言中，泛型通配符是一种用于表示未知类型的符号，它在处理泛型类型（可以适用于多种数据类型的类型）时非常有用。以 Java 为例，`?` 是泛型通配符。它允许编写更灵活的代码，特别是在处理像集合（如 `List`、`Set`、`Map` 等）这样的泛型类型时。
2. **使用场景和目的**
   - 增强代码的灵活性
     - 假设我们有一个方法，它接受一个 `List`，但我们不关心这个 `List` 中元素的具体类型，只需要对这个列表进行一些通用的操作，如打印列表中的元素个数。在 Java 中，我们可以使用泛型通配符来定义这个方法：

```java
       public void printListSize(List<?> list) {
           System.out.println(list.size());
       }
```



这样，这个方法可以接受任何类型的 `List`，如 `List`、`List` 等。

- 限制类型的范围（有界通配符）
  - 除了简单的 `?`，还有有界通配符。例如，`` 表示这个通配符可以是 `Number` 类型或者是 `Number` 的子类类型。在 Java 中，如果我们想编写一个方法来计算一个 `List` 中所有元素的总和，并且这个 `List` 中的元素必须是数字类型，我们可以这样写：

```java
       public double sumList(List<? extends Number> list) {
           double sum = 0;
           for (Number num : list) {
               sum += num.doubleValue();
           }
           return sum;
       }
```

这里的 `确保了 `list` 中的元素要么是 `Number` 本身，要么是 `Number` 的子类（如 `Integer`、`Double` 等），这样就可以安全地调用 `doubleValue 方法来进行求和计算。

- 还有一种有界通配符是 <? super Integer>，它表示这个通配符可以是 `Integer` 或者是 `Integer` 的父类类型。这种用法在往集合中添加元素时比较有用。例如，我们有一个方法，它可以将一个 `Integer` 添加到一个集合中，并且这个集合中的元素类型应该是 `Integer` 或者是 `Integer` 的父类，我们可以这样写：

```java
public void addInteger(List<? super Integer> list, Integer num) {
           list.add(num);
       }
```

### List接口

#### 特性描述


列表是有序的集合(有时称为序列)。列表可能包含重复的元素。

Java平台包含两个常用的List实现。 ArrayList通常是性能较好的实现，而LinkedList在某些情况下可以提供更好的性能

#### List接口常用方法

```java
E get(int index);//获取给定位置的元素
E set(int index，E element);//修改给定位置的元家
void add(int index，E element);//在给定位置插入一个元素
E remove(int index);//移除给定位置的元素
int indexof(object o)://获取给定元素第一次出现的下标
int lastIndexof(obiect o);//获取给定元素最后一次出现的下标
ListIterator<E> listIterator();//获取List集合专有的迭代器
ListIterator<E> 1istIterator(int index);//获取List集合专有的迭代器，从给定的下标位置开始的选代器
List<E> subList(int fromIndex,int toIndex)://获取List集合的一个子集合
```



#### ArrayList

<font color = "red">示例以及源码解读</font>



```java
package src.list;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.ListIterator;

public class ArrayListTest {
    public static void main(String[] args) {

        //集合有序是值存储顺序与遍历时取出来的顺序一直
        ArrayList<String> list = new ArrayList<>();
        list.add("a");
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        //a a b c d => a a e b c d
        list.add(2, "e");
        //将第一个改为g
        String old = list.set(1, "g");
        for (String s : list) {
           System.out.println(s);
        }


        Iterator<String> iter = list.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }

        //listIterator()方法返回一个列表迭代器，该迭代器允许程序员以双向方式遍历列表，并修改列表中的元素
        ListIterator<String> listIter = list.listIterator();
        while (listIter.hasNext()) {
            System.out.println(listIter.next());
        }
        //从后往前遍历
        ListIterator<String> prevIterator = list.listIterator(list.size());
        while (prevIterator.hasPrevious()) {
            System.out.println(prevIterator.previous());
        }


        ArrayList<Integer> numbers= new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.remove(3);
        //这是移除下标为3的元素，还是移除3这个元素
        //答案：移除下标为3
        //这是移除3这个元素
        numbers.remove((Integer)3);
        for (Integer number : numbers) {
            System.out.println(number);
        }
        numbers.add(2);
        numbers.add(2);
        int index1 = numbers.indexOf(2);
        int index2 = numbers.lastIndexOf(2);

        //获取一个子集合
        ArrayList<String> subList = new ArrayList<>(list.subList(1, 3));

    }
}

```



`ensureCapacityInternal`确保数组有足够的容量来添加新的数据



`void grow (int minCapacity)`实现数组扩容，扩容是原来的1.5倍



ArrayList集成于AbstractList，AbstracList继承于Abstractcollection



ListItr可以从前到后对集合进行遍历，也可以从后往前对集合进行遍历，还可以向集合添加元素，修改元素

<font color ="red">ArrayList底层采用的是数组来存储元素，根据数组的特性，ArrayList在随机访问时效率极高，在增加和删除时效率低，因为在增加和删除元素时会涉及到数组中元素位置的移动。数组扩容时，扩容是原来的1.5倍。</font>





在 Java 中，`Iterator numbers = list.iterator();`这条语句的作用是创建一个迭代器（`Iterator`）对象，用于遍历存储字符串元素的`ArrayList`（假设`list`是一个`ArrayList`对象）。

1. **迭代器的基本概念**

   迭代器是一种设计模式，它提供了一种方法来顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。在 Java 中，`Iterator`接口定义了用于遍历集合的标准方法。

2. **该语句的具体解释**

   - `list.iterator()`：这是调用`ArrayList`对象的`iterator`方法，返回一个`Iterator`类型的迭代器。这个迭代器可以用来遍历`list`中的字符串元素。
   - `Iterator numbers`：这是声明一个迭代器变量`numbers`，它的类型是`Iterator`，表示这个迭代器将用于遍历字符串类型的元素。

3. **使用迭代器进行遍历的示例**

```java
   import java.util.ArrayList;
   import java.util.Iterator;

   public class IteratorExample {
       public static void main(String[] args) {
           ArrayList<String> list = new ArrayList<>();
           list.add("apple");
           list.add("banana");
           list.add("cherry");

           Iterator<String> numbers = list.iterator();
           while (numbers.hasNext()) {
               String element = numbers.next();
               System.out.println(element);
           }
       }
   }
```



在上述示例中，首先创建了一个包含三个字符串元素的`ArrayList`。然后，通过`list.iterator()`获取迭代器，并使用`while`循环和`hasNext`、`next`方法遍历集合中的元素并打印出来。



**迭代器的其他方法**

- `hasNext()`：用于判断集合中是否还有更多的元素可以遍历。
- `next()`：返回集合中的下一个元素。
- `remove()`：用于从集合中移除当前由`next`方法返回的元素。



#### LinkList链表

单向链表

```java
package src.list;
/*
自定义单向链表
<T> 泛型变量
 */
/*
这是一个使用泛型类型参数 T 定义的类。泛型允许你编写可以适用于不同数据类型的代码，
而无需为每种数据类型都编写重复的代码。例如，你可以使用 MyNode<Integer> 创建一个存储整数的节点类，
也可以使用 MyNode<String> 创建存储字符串的节点类。
 */
public class MyNode<T> {
    private T data;
    //链中存储的数据
    private MyNode<T> next;

    public MyNode(MyNode<T> next, T data) {
        this.next = next;
        this.data = data;
    }
    public T getData() {
        return data;
    }
    public void setData(T data) {
        this.data = data;
    }
    public MyNode<T> getNext() {
        return next;
    }
    public void setNext(MyNode<T> next) {
        this.next = next;
    }

}

package src.list;

public class MyNodetest {
    public static void main(String[] args) {
        MyNode<String> first = new MyNode<String>(null, "第一个链");

        MyNode<String> second = new MyNode<String>(null, "第二个链");
        first.setNext(second);
        MyNode<String> third = new MyNode<String>(null, "第三个链");
        second.setNext(third);
        MyNode<String> nextNode = first;
        while (nextNode != null) {
            System.out.println(nextNode.getData());
            nextNode = nextNode.getNext();
        }
    }
}


```



![image-20241010212611479](C:\Users\22373\AppData\Roaming\Typora\typora-user-images\image-20241010212611479.png)

双向链表

```java
package src.list;
/*
自定义双向链表
 */
public class DeNode<T> {
        private T data;
        //链中存储的数据

        private DeNode<T> next;
        //下一个节点

        private DeNode<T> prev;
         //上一个节点


    public DeNode(T data, DeNode<T> prev, DeNode<T> next) {
        this.data = data;
        this.prev = prev;
        this.next = next;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public DeNode<T> getNext() {
        return next;
    }

    public void setNext(DeNode<T> next) {
        this.next = next;
    }

    public DeNode<T> getPrev() {
        return prev;
    }

    public void setPrev(DeNode<T> prev) {
        this.prev = prev;
    }
}


package src.list;

public class DeNodeTest {
    public static void main(String[] args){
        DeNode<Integer> first = new DeNode<>(1, null, null);
        DeNode<Integer> second = new DeNode<>(2, first, null);
        first.setNext(second);
        DeNode<Integer> third = new DeNode<>(3, second, null);
        second.setNext(third);
        DeNode<Integer> nextNode = first;
        while (nextNode != null){
            System.out.println(nextNode.getData());
            nextNode = nextNode.getNext();
        }


        //从后往前
        DeNode<Integer> prevNode = third;
        while (prevNode != null){
            System.out.println(prevNode.getData());
            prevNode = prevNode.getPrev();
        }


    }
}

```



LinkedList 继承于AbstractSequentialList，AbstractSequentialList继承于AbstractList

##### LinkedList

```java
package src.list;

import java.util.LinkedList;

public class LinkeListTest {
    public static void main(String[] args){
        LinkedList<String> list = new LinkedList<>();
        list.add("1");
        list.addLast("2");
        list.addFirst("3");
        String first = list.removeFirst();
        //将第一个链移除
        String last = list.removeLast();

    }
}

getList
getfirst

```

##### 栈

```java
package src.list;

import java.util.ArrayList;

/*
自定义栈
 */
public class Mystack<T> extends ArrayList<T> {

    public void push(T t){//入栈
        add(t);
    }
    public T pop() { //出栈
        if(size() == 0) {
            throw new RuntimeException("栈为空");
        }
        T t = get(size() - 1);
        remove(t);
        return t;
    }
}

```

##### 练习：

从控制台中录入5位学生信息：姓名 性别 年龄 成绩 ，并将这些学生信息以， 连接起来，然后存储到文本中，再从文本中讲这些信息读取到集合中。

```java
package src.list;

public class Student {
     private String name;
     private int age;
     private String gender;
     private int score;

    public Student(String name, int score, String gender, int age) {
        this.name = name;
        this.score = score;
        this.gender = gender;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }
    @Override
    public String toString() {
        return name+","+score+", "+gender+", "+age;
    }
}


package src.list;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Exercise {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < 5; i++) {
            System.out.println("请输入学生的姓名");
            String name = sc.next();
            System.out.println("请输入学生的年龄");
            int age = sc.nextInt();
            System.out.println("请输入学生的分数");
            int score = sc.nextInt();
            System.out.println("请输入学生的性别");
            String gender = sc.next();
            students.add(new Student(name, age, gender, score));
        }
        saveStudents(students, "D:\\students.txt");

        List<Student> students1 = readStudents("D:\\students.txt");
        for (Student student : students1) {
            System.out.println(student);
        }
    }

    private static List<Student> readStudents(String path) {
        List<Student> students = new ArrayList<>();
        try (FileReader reader = new FileReader(path);) {
            BufferedReader br = new BufferedReader(reader);
            String line;
            while ((line = br.readLine()) != null) {
                String[] split = line.split(",");
                //按照逗号分隔读取
                students.add(new Student(split[0], Integer.parseInt(split[1]), split[2], Integer.parseInt(split[3])));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return students;
    }
    private static void saveStudents(List<Student> students,String path) {
        File file= new File(path);
        File parent = file.getParentFile();
        if (!parent.exists()) {
            parent.mkdirs();
        }
        try (FileWriter writer = new FileWriter(file);){
            BufferedWriter bw = new BufferedWriter(writer);
            for (Student student : students) {
                bw.write(student.toString());
                bw.newLine();
            }
            bw.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }
}

```

### queue接口

队列是用于在处理之前保存元素的集合。 除了基本的收集操作外，队列还提供其他插入，移除和检查操作。

队列通常但不是必须以FIFO(先进先出)的方式对元素进行排序。 优先队列除外，它们根据元素的值对元素进行排序(有关详细信息，请参见“对象排序"部分)。 无论使用哪种排序，队列的开头都是将通过调用remove或poll删除的元素。 在FIFO队列中，所有新元素都插入到队列的尾部。其他种类的队列可能使用不同的放置规则。每个Queue实现必须指定其排序属性。

**Queue接口常用方法**

```java
boolean add(E e);//向队列中添加一个元素，如果出现异常，则直接抛出异常
boolean offer(e e);//向队列中添加一个元素，如果出现异常，则返回fa1se
E remove();//移除队列中第一个元素，如果队列中没有元素，则将抛出异常E Po11();//移除队列中第一个元素，如果队列中没有元素，则返回nu11
E element();//获取队列中的第一个元素，但不会移除。如果队列为空，则将抛出异常
E peek();//获取队列中的第一个元素，但不会移除。如果队列为空，则返回nu11
```

#### linkedBlockingQueue

linkedBlockingQueue是一个FIFO队列，队列有长度，超出长度范围的元素将无法存储进队列

```java
package src.list.queue;
import java.util.concurrent.LinkedBlockingQueue;


public class LinkedBlockingQueueTest {
    public static void main(String[] args) {
        //构建队列时，我们通常都会给队列设置一个容量，因为默认容量太大了
        LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>(5);
        queue.add("1");
        queue.add("2");
        queue.add("3");
        queue.add("4");
        queue.add("5");
        //queue.add("6");//放入第六个元素的时候，报错
        boolean success = queue.offer("6");
        //放入第六个元素的时候，返回false
        queue.remove("1");
        queue.remove("2");
        String s = queue.poll();
        //移除元素，若没有则返回null
    }
}
```



#### PriorityQueue

PriorityQueue是一个有排序规则的队列，存入进去的元素是无序的，超出长度范围的元素将无法存储进队列。需要注意的是，**如果存储的元素如果不能进行比较排序，也未提供任何对元素进行排序的方式，运行时会抛出异常。**

```java
package src.list;

import java.util.PriorityQueue;

public class PriorityQueueTest {
    public static void main(String[] args){
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        queue.add(1);
        queue.add(2);
        while (!queue.isEmpty()){
            Integer number = queue.poll();
            System.out.println(number);
        }

    }
}

```

**自带排序规则，但是存储的是对象，该怎么排呢**

![image-20241017202601198](C:\Users\22373\AppData\Roaming\Typora\typora-user-images\image-20241017202601198.png)

<font color = 'red'>如果对象不能进行比较，则不能排序，运行时会报异常。要解决这个问题，需要使用Java平台提供的比较器接口</font>

### 比较器接口

#### 比较器接口的作用

在使用数组或者集合时，我们经常都会遇到排序问题，比如将学生信息按照学生的成绩从高到低依次排列。数字能够直接比较大小，对象不能够直接比较大小，为了解决这个问题，Java平台提供了comparable和comparator 两个接口来解决。

#### comparable接口

```java
接口对实现的每个类的对象强加了总体排序，此排序称为类的自然排序，而该类的compareTo方法被称为其自然比较方法
    
```

<font color ="red">两个对象在集合中比较</font>

```java
package src.list;

public class User implements Comparable<User>{
    private String name;
    private int level;

    public User(String name, int level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public String toString() {
        return super.toString();
    }
    @Override
    public int compareTo(User o) {
        if(level ==o.level){
            return 0;
        }else if(level > o.level){
            return 1;
        }else{
            return -1;
        }
    }
}
//定义了一个compareTo方法，用于比较当前对象（假设所在类包含一个level属性，表示某种级别）和另一个User对象的level属性。根据比较结果返回相应的值，以确定两个对象在某种排序规则下的相对顺序。
/*
比较逻辑
首先判断当前对象的level和传入对象o的level是否相等。
如果相等，即level == o.level，则返回0。这表示在排序规则下，两个对象是相等的，它们在排序结果中应该处于相同的位置。
如果当前对象的level大于传入对象的level，即level > o.level，则返回1。这意味着在排序规则下，当前对象应该排在传入对象之后。
如果当前对象的level小于传入对象的level，即level < o.level，则返回-1。这表明在排序规则下，当前对象应该排在传入对象之前。
*/

package src.list;

import java.util.PriorityQueue;

public class PriorityQueueTest {
    public static void main(String[] args){
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        queue.add(1);
        queue.add(2);
        while (!queue.isEmpty()){
            Integer number = queue.poll();
            System.out.println(number);
        }

        PriorityQueue<User> userQueue = new PriorityQueue<>();
        userQueue.offer(new User("Alice", 0));
        userQueue.offer(new User("Bob", 1));
        userQueue.offer(new User("Charlie", 2));
        userQueue.offer(new User("David", 3));
        while (!userQueue.isEmpty()){
            User user = userQueue.poll();
            System.out.println(user);
        }
    }
}


```





**示例二**

```java
package src.list.compare;

public class Student implements Comparable<Student> {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    @Override
    public int compareTo(Student o) {
        if(age == o.age){
            return name.compareTo(o.name);
            //年龄相同时，比较名字
        }else if(age < o.age) {
            return 1;
        } else {
            return -1;
        }
    }
}
```

```java
package src.list.compare;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

public class ComparableTest {
    public static void main(String[] args) {
        Student[]  students ={
                new Student("张三", 18),
                new Student("李四", 20),
                new Student("王五", 19),
                new Student("赵六", 17),
        };
        Arrays.sort(students);
        for (Student student : students) {
            System.out.println(student);
        }



        List<Student> studentList = new ArrayList<>();
        studentList.add(new Student("张三", 18));
        studentList.add(new Student("李四", 20));
        studentList.add(new Student("王五", 19));
        studentList.add(new Student("赵六", 17));
        Collections.sort(studentList);
        //对集合排序
        for (Student student : studentList) {
            System.out.println(student);
        }
    }


}

```

#### Comparator接口

```reStructuredText
比较功能，对某些对象集合施加总排序。可以讲比较器传递给排序方法（列如collections.sort或Arrays,sort）,以实现对排序顺数的精准控制
```

外排序器

```java
package src.list.compare;

import java.util.*;

public class ComparatorTest {
    public static void main(String[] args) {
        Course[] courses = {
                new Course("Math", 100),
                new Course("English", 90),
                new Course("Physics", 80),
                new Course("Chemistry", 70),
                new Course("Biology", 60)
        };

//        Comparator<Course> comparator = new Comparator<Course>(){
//            @Override
//            public int compare(Course o1, Course o2) {
//                return 0;
//            }
//        };
        //匿名内部类可以简化
        Comparator<Course> c = (o1, o2) -> {
            int score1 = o1.getScore();
            int score2 = o2.getScore();
            if(score1 == score2){
                return o1.getName().compareTo(o2.getName());
            }else if(score1 > score2){
                return -1;
            }else{
                return 1;
            }
        };
        Arrays.sort(courses,c);
        for (Course course : courses) {
            System.out.println(course);
        }

        //++++++++++++++++++++++++++++++++++++++++++

        List<Course> courseList = new ArrayList<>();
        courseList.add(new Course("Math", 100));
        courseList.add(new Course("English", 90));
        courseList.add(new Course("Physics", 80));
        courseList.add(new Course("Chemistry", 70));
        courseList.add(new Course("Biology", 60));
        Collections.sort(courseList,c);
        for (Course course : courseList) {
            System.out.println(course);
        }

    }
}

```

<font color = "red">Comparable接口是由数组或者集合中的对象的类所实现，实现后对象就拥有比较的方法，因此称为内排序或者自然排序。comparator
接口是外部提供的对两个对象的比较方式的实现，对象本身并没有比较的方式，因此被称为外排序器</font>

### Map接口及实现

#### 特性描述

Map集合是将键映射到值的对象。映射不能包含再复的键:每个键最多可以映射到一个值，
Java平台包含三个常用Map的实现:HashMap，TreeMap和LinkedHashMap。
**Map 接口常用方法**

```java
int size();//获取集合的大小
boolean isEmpty();//判断集合是否为空
boolean containsKey(object key);//判断集合中是否包含给定的键
boolean containsvalue(object value);//判断集合中是否包含给定的值
V get(object key);//获取集合中给定键对应的值
V put(K key，v value);//将一个键值对放入集合中
V remove(object key);//将给定的键从集合中移除
void putA11(Map<?extends K，?extends V> m);//将给定的集合添加到集合中
void clear();//清除集合中所有元素
set<K> keyset();//获取集合中键的集合
collection<V>values();//获取集合中值的集合
Set<Map.Entry<K，V>>entryset();//获取集合中键值对的集合

```

**Entry接口常用方法**

```java
getkey();//获取键
getvalue();//获取值V
V setvalue(v value);//设置值
boolean equals(object o);//比较是否是同一个对象
int hashcode();//获取哈希码
```

```java
Map基本操作：
Map 初始化

Map<String, String> map = new HashMap<String, String>();

插入元素

map.put("key1", "value1");

获取元素

map.get("key1")

移除元素

map.remove("key1");

清空map

map.clear();

```

<font color = "red">Map接口中的内部接口就是map存储的数据项，一个Entry就是一个键值对</font>

#### HashMap

```java
基于哈希表的Map接口的实现。此实现提供所有可选的映射操作，并允许空值和空键。(HashMap类与Hashtab1e大致等效，不同之处在于它是不同步的，并且允许为nu11。)该类不保证映射的顺序。 特别是，它不能保证顺序会随着时间的推移保持恒定。
```

Hashmap存储的是一组无序的键值对。存储时是根据键的哈希码来计算存储的位置，因为对象的哈希码是不确定的，因此Hashmap存储的元素时无序的。

**示例以及源码解读**

HashMap采用的是数组加单向链表加红黑树的组合来存储数据

```java
package src.list.compare;

import java.util.*;

public class HashMapTest {
    public static void main(String[] args){
        //HashMap采用的是数组、链表、以及红黑树来存储元素
        //链表的设计主要是针对Hash碰撞而引发的存储位置冲突
        //红黑树的设计主要是针对链表长度过长而引发的查询效率低下
        HashMap<Integer,String> map = new HashMap<>();
        map.put(1,"a");
        map.put(2,"b");
        map.put(3,"c");
        map.put(4,"d");
        map.put(17,"e");
        String value = map.get(1);
        System.out.println(value);
        System.out.println(map.size());
        System.out.println(map.isEmpty());
        System.out.println(map.containsKey(1));
        System.out.println(map.containsValue("a"));

        HashMap<Integer,String> map1 = new HashMap<>();
        map1.put(5,"f");
        map1.put(6,"g");
        map1.put(7,"h");
        map.putAll(map1);
        //将map1全部 放入map中
        System.out.println(map.size());

        //获取键的集合
        Set<Integer> keySet = map.keySet();
        for(Integer key : keySet){
            System.out.println(key);
        }
        //获取值的集合
        Collection<String> values = map.values();
        for(String str : values){
            System.out.println(str);
        }

        Set<Map.Entry<Integer,String>> entrySet = map.entrySet();
        for(Map.Entry<Integer,String> entry : entrySet){
            System.out.println(entry.getKey()+" "+entry.getValue());
        }
    }
}

```

```java
map.entrySet():

entrySet()是Map接口的一个方法，它返回一个Set<Map.Entry<K,V>>类型的集合，其中K和V分别是Map的键和值的类型。这个集合包含了Map中的所有键值对，每个键值对以Map.Entry对象的形式表示。
    
Set<Map.Entry<Integer,String>> entrySet = map.entrySet();

这里将map.entrySet()返回的集合赋值给一个新的变量entrySet。这个变量的类型是Set<Map.Entry<Integer,String>>，表示它是一个包含Map.Entry<Integer,String>类型元素的集合。Map.Entry<Integer,String>表示键为Integer类型、值为String类型的键值对。
```

#### TreeMap

```java
基于红黑树的NavigableMap实现。根据集合存储的键的自然排序或在映射创建时提供的Comparator来对键进行排序，具体取决于所使用的构造方法
```

````java
package src.list.mao;

public class computer implements Comparable<computer> {

    private String brand;
    private int price;

    public computer(String brand, int price) {
        this.brand = brand;
        this.price = price;
    }

    public String getBrand() {
        return brand;
    }

    public int getPrice() {
        return price;
    }
    @Override
    public String toString() {
        return "computer{" +
                "brand='" + brand + '\'' +
                ", price=" + price +
                '}';
    }
    @Override
    public int compareTo(computer o) {
        return Double.compare(this.price, o.price);
    }
}


package src.list.mao;

import java.util.Comparator;
import java.util.TreeMap;

/**
 * @author 22373
 */
public class TreeMapTest {
    public static void main(String[] args) {
        TreeMap<computer, Integer> map = new TreeMap<>();
        map.put(new computer("联想", 3000), 1);
        map.put(new computer("戴尔", 4000), 2);
        map.put(new computer("惠普", 5000), 3);

        for (computer key : map.keySet()) {
            System.out.println(key + "--->" + map.get(key));
        }


        //匿名内部类形式
//        Comparator<computer> comparator = new Comparator<computer>() {
//            @Override
//            public int compare(computer o1, computer o2) {
//                return 0;
//            }
//        ;


//        Comparator<computer> c = ( o1 , o2) -> {
//            return  Double.compare(o1.getPrice(), o2.getPrice());
//        };

        Comparator<computer> c = ( o1 , o2) -> Double.compare(o1.getPrice(), o2.getPrice());

        TreeMap<computer, Integer> map1 = new TreeMap<>();
        map1.put(new computer("联想", 3000), 1);
        map1.put(new computer("戴尔", 4000), 2);
        map1.put(new computer("惠普", 5000), 3);
        for (computer key : map1.keySet()) {
            System.out.println(key + "--->" + map.get(key));
        }

    }
}

````

需要排序时，第一种方法是写出CompareTo接口

第二种是写出外部排序器 



```java
src.list.mao.computer@b4c966a--->1

src.list.mao.computer@3d494fbf--->2 src.list.mao.computer@1ddc4ec2--->3



这个输出看起来是因为在`computer`类中没有重写`Object`类的`toString()`方法，所以在输出`computer`对象时，默认调用了`Object`类的`toString()`方法，输出了对象的哈希码表示形式。



要解决这个问题，可以在`computer`类中重写`toString()`方法，
```

#### LinkedHashMap

```java
Map接口的哈希表和链表实现，具有可预测的迭代顺序。此实现与HashMap的不同之处在于，他维护一个贯穿所有条目的双向链表。此链表定义了迭代顺序，通常是将键插入映射的顺序（插入顺序）。注意，如果将键重新插入到映射中，则插入顺序不收到影响。
```

```java
package src.list.mao;

import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapTest {

    public static void main(String[] args) {
        LinkedHashMap<String, String> map = new LinkedHashMap<>();
        map.put("1", "a");
        //第一次是放入
        map.put("2", "b");
        map.put("3", "c");
        map.put("4", "d");

        map.put("1", "ook");
        //第二次是更新
        for (String key : map.keySet()) {
            System.out.println(key);
        }
        

        for(Map.Entry<String,String>entry: map.entrySet()){
            System.out.println(entry.getKey() + " : " + entry.getValue());
        }
    }
}

```

![image-20241022174603916](C:\Users\22373\AppData\Roaming\Typora\typora-user-images\image-20241022174603916.png)



### Set接口

#### HashSet

```java
集合是一个集合，不能包含重复的元素。 它为数学集合抽象建模。 set接口仅包含从collection继承的方法，并增加了禁止重复元素的限制。set还为equals和hashcode操作的行为增加了更紧密的约定，即使它们的实现类型不同，也可以有意义地比较set实例。如果两个set实例包含相同的元素，则它们相等。

Java平台包含三个通用的set实现:Hashset;Treeset和LinkedHashset。 Hashset将其元素存储在哈希表中，是性能最好的实现。 但是。
它不能保证迭代的顺序。
```

<font color ="red">示例以及源码解读</font>

```java
package src.list.mao;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class HashSetTest {
    public static void main(String[] args){
        HashSet<String> set = new HashSet<>();
        set.add("a");
        set.add("a");
        System.out.println(set.size());
        //size值为1，因为哈希不能包含重复的元素

        HashSet<String> set1 = new HashSet<>();
        set1.add("A");
        set1.add("B");
        set1.add("C");
        set.addAll(set1);
        //是否包含
        System.out.println(set.contains("C"));
        //删除
        System.out.println(set.remove("C"));

        Iterator<String> iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}

```

#### TreeSet

```java
基于TreeMap的NavigableSet实现。元素使用其自然排序或子啊集合创建时提供Comparator进行排序，具体取决于所使用的构造方法
```

```java
package src.list.mao.TreeSet;

import java.util.Comparator;

public class Car {
//        implements Comparable<Car> {
    private String brand;
    private int price;
    public Car(String brand, int price) {
        this.brand = brand;
        this.price = price;
    }
    public String getBrand() {
        return brand;
    }
    public int getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "Car{" +
                "brand='" + brand + '\'' +
                ", price=" + price +
                '}';
    }
//    @Override
//    public int compareTo(Car o) {
//        return Double.compare(price, o.price);
//    }

}


package src.list.mao.TreeSet;

import java.util.Comparator;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * @author 22373
 */
public class TreeMapTest  {
    public static void main(String[] args) {
//        TreeSet<Car> cars = new TreeSet<>();
//        cars.add(new Car("BWM", 550));
//        cars.add(new Car("大众", 200));
//        for (Car car : cars) {
//            System.out.println(car);
//        }

        Comparator<Car> c = (o1, o2) -> Double.compare(o1.getPrice(), o2.getPrice());
        TreeSet<Car> cars = new TreeSet<>(c);
        cars.add(new Car("BWM", 550));
        cars.add(new Car("大众", 200));
        for (Car car : cars) {
            System.out.println(car);
        }
    }
}


```

